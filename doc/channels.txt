ZeroVM channels description
(up to date 2014-05-12)
---------------------------

Channels are the key component of the ZeroVM I/O subsystem. On the host system
side, channels are backed by the file system using regular files, pipes,
character devices or unix domain sockets. On the guest side, the channel is
a device file. It could be used as either character or block device depending
on the usage pattern and access type (see access types below). The "Channel"
keyword is passed via the manifest to ZeroVM (comma delimited, see examples
below). this keyword can (and should) be used more than once per manifest.
It is possible to use integers in octal, decimal and hexadecimal notation.

Channel = [uri], [alias], [type], [gets], [get_size], [puts], [put_size]
uri      - can be a local file, pipe, character device or node identifier
  (see more details below).
alias    - channel name for the user side.
type     - access type.
  0: sequential read / sequential write (can be used as character device)
  1: random read / sequential write
  2: sequential read / random write
  3: random read / random write
gets     - limit for reads allowed from this channel
get_size - limit on total amount of data to be read from this channel in bytes
puts     - limit for writes allowed for this channel
put_size - limit on total amount of data to be written to this channel in bytes

Fields available for the untrusted code (see api.txt):
limits -- 4 limits for the channel (reads/writes in bytes and "syscall" counts)
size -- channel size. only available for random access channels
type -- access type
name -- the channel name (the alias from the manifest)
the indices in the channels array can be used as "handles". also it is
guaranteed that handles 0..2 represent /dev/stdin, /dev/stdout and /dev/stderr

For now ZeroVM supports 6 kinds of channels (defined by combination of
access type and 4 read/write limits):
- sequential read only channel (access type 0, both write limits are 0)
- random read only channel (access type 3, both write limits are 0)
- sequential write only channel (access type 0, both read limits are 0)
- random write only channel (access type 3, both read limits are 0)
- appendable channel. random read, sequential write. if the channel is not empty
  the write position is set next to the last byte (access type 1, any limits)
- full random access channel. can be read or written from any valid position
  (access type 3, any limits)

There are 3 mandatory channels (standard c90 streams): stdin, stdout, stderr.
The channels have well known device names "/dev/stdin", "/dev/stdout" and
"/dev/stderr". all mandatory channels must present in the manifest.
usually /dev/stdin is a sequential read only channel, /dev/stdout is a
sequential write only channel and /dev/stderr is a sequential write only
channel. however standard channels' access types can be redefined in the
system manifest (not recommended).

A channel is a file abstraction over local files and network streams. Local
files can have the random access type, while network streams are always
sequential.

All channels are opened before the session start and closed after the session
end.  In the case of a channel i/o error, ZeroVM will not start. ZeroVM
preallocates the specified byte size for the local writable channels (this can
be changed with the -P switch, see zerovm_switches.txt).

Network (pipe) channels
-------------------------------
ZeroVM can operate channels using domain name sockets (unix sockets) when
a network broker is available. in that case system manifest should contain
"Broker" key with proper value (name of unix soket where broker will listen
to request). system manifest also must contain "Node" key with not empty
value. node name is part of agreement between network broker and ZeroVM (for
further details see "broker.txt").

network channels names is part of broker protocol (see "broker.txt"). network
channels are unidirectional. which means they are read only or write only.
network channels can only have sequential access.

Each read from read only network channel can result in zvm_eof indicator read.
This means that the other party closed the channel, you will get the same
zvm_eof each time you try to read from this channel again.

Node identifiers
----------------
Node id and channel id (which is id of connected node) are not zerovm's
responsibility. Manifest provider and broker should have agreement about
node/channel naming convention. ZeroVM treat node id as a string.

If the manifest contains "Broker", "Node" and node identifier(s) in channel(s)
definition ZeroVM will do the following on startup:
1. open connection to broker using path specified by "Broker" value
2. mount channel(s) with node id in name field using "Node" from manifest and
   channel(s) definition to ask read or write only mode for the channel(s)

After these operations the channels will be set up with correct unidirectional
data paths. You can use ZeroVM networked samples to see the flow, namely
'netcopy' or 'demo/channels' sample. To find more info about broker consult
broker.txt

examples
-----------
Channel = /tmp/file.tmp, /dev/stderr, 0, 0, 0x100, 1048576
  will map the "/tmp/file.tmp" file from the host system to the "/dev/stderr"
  alias (the name visible to user code in untrusted execution)
  the channel has sequential access
  the channel is write only ("0, 0" in positions 5, 6 means no read possible)
  it is possible to make 256 writes (specified in position 7)
  it is possible to write 1048576 bytes (specified in position 8)

Channel = /dev/stdin, /dev/stdin, 0, 07, 0x1000, 0, 0
Channel = 55431, /dev/in/some_host, 0, 0x1000000, 0x100000000, 0, 0
Channel = 12345, /dev/out/node13, 0, 0, 0, 13, 1313

Limitations
-----------
- The number of channels in the manifest is limited to 10915 "Channel" lines
- the user program cannot use a network channel to itself
